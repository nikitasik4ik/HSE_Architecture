# Сервис для поиска пропавших домашних животных
В качестве основного варианта использования для описания был выбран процесс . Для упрощения на диаграмме компонентов показаны не все необходимые связи для выполнения запросов, а лишь основные неоходимые для общего понимания принципа работы. 
Код написан так же с упрощением. Реализованы только те методы, которые необходимы для выполнения требуемоего варианта использования.

## Диаграмма компонентов API Пользователя
![image](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/38eee4f1-b3e4-4ea0-8cd2-ad53cac5dff5)

## Диаграмма последовательности
![image](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/3bbc6b22-53bf-456c-8a0f-cc2ec28f9f92)

## Модель БД
![drawSQL-image-export-2024-03-09](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/27eb9ce4-eb72-4ac3-bd20-c5af87def43f)

## Применение основных принципов разработки
Клиентский код:

В клиентском коде были учтены следующие принципы:

KISS (Keep It Simple, Stupid) - код прост и понятен. Он не содержит избыточных деталей и лишних сложностей, что упрощает его понимание и поддержку.

YAGNI (You Ain't Gonna Need It) - код реализует только необходимый функционал для работы с приложением. Не добавлены ненужные фичи, которые могут привести к излишней сложности и перегрузке системы.

DRY (Don't Repeat Yourself) - код структурирован таким образом, чтобы избежать дублирования кода. Методы get_patient_info, get_symptoms, send_diagnosis_request и display_diagnosis выделены в отдельные функции для повторного использования и улучшения поддерживаемости кода.

SOLID - класс DiagnosticsApp следует принципу единственной ответственности, так как он отвечает только за запуск приложения и координацию работы других компонентов. Каждый метод класса выполняет только одну задачу. Также класс легко расширяем и поддерживаем, так как методы могут быть заменены или переопределены при необходимости.

Серверный код:

В серверном коде были учтены следующие принципы:

KISS (Keep It Simple, Stupid) - код сервера написан с использованием фреймворка Flask, который предоставляет простой и понятный способ создания веб-приложений. Код сервера минимален и выполняет только одну функцию - обработку запросов и отправку диагноза.

YAGNI (You Ain't Gonna Need It) - серверный код реализует только необходимый функционал для обработки запроса на диагностику. Не добавлены ненужные фичи, которые могут привести к излишней сложности и перегрузке системы.

DRY (Don't Repeat Yourself) - функция process_diagnosis выделена для обработки информации о пациенте и симптомах. Она может быть повторно использована в других частях кода, что улучшает поддерживаемость и избегает дублирования кода.

SOLID - код сервера построен на принципе единственной ответственности. Функция diagnose отвечает только за обработку запроса и возврат диагноза. Код легко расширяем и поддерживаем, так как функции могут быть заменены или переопределены при необходимости.

## Дополнительные принципы разработки
1. BDUF. Применимость: Отказ. При проектировании web-приложения для диагностирования легочных заболеваний, необходимо учитывать, что требования и технические решения могут меняться в процессе разработки. Поэтому масштабное проектирование прежде всего может привести к излишней сложности и избыточности, а также затруднить внесение изменений в процессе разработки.

2. SoC. Применимость: Применим. Принцип разделения ответственности позволяет разделять функциональность системы на отдельные компоненты, что упрощает поддержку и расширение кода. Например, разделение интерфейса для отправки данных на сервер и отображения результатов анализа позволяет изменять эти части независимо друг от друга.

3. MVP. Применимость: Применим. Разработка минимально жизнеспособного продукта позволяет быстрее вывести продукт на рынок, получить обратную связь от пользователей и внести необходимые изменения. Это особенно важно при создании web-приложения, где быстрый запуск и обновление функциональности являются ключевыми.

4. PoC. Применимость: Применим. Доказательство концепции позволяет проверить работоспособность и целесообразность выбранных технических решений, например, обучение нейросети для диагностирования легочных заболеваний. Это поможет избежать потенциальных проблем и ошибок на более поздних этапах разработки.
