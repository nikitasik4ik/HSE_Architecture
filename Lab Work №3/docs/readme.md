# Сервис для поиска пропавших домашних животных
В качестве основного варианта использования для описания был выбран процесс публикации записи о пропавшем домашнем животном. Для упрощения на диаграмме компонентов показаны не все необходимые связи для выполнения запросов, а лишь основные неоходимые для общего понимания принципа работы. 
Код написан так же с упрощением. Реализованы только те методы, которые необходимы для выполнения требуемоего варианта использования.

## Диаграмма компонентов API Пользователя
![image](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/38eee4f1-b3e4-4ea0-8cd2-ad53cac5dff5)

## Диаграмма последовательности
1. Пользователь с помощью веб-интерфейса отправляет запрос на публикацию записи.
2. Запрос передается с помощью Publication Controller.
3. Publication Controller отправляет запрос в Publication Service и получаете ответ с помощью Publication Repository.
4. Создается новую запись в Базе данных.
5. Publication Controller выводит новую запись в веб-инетрфейс.
![image](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/3bbc6b22-53bf-456c-8a0f-cc2ec28f9f92)

## Модель БД
Сущности 
1. Сущность User - содержит информацию о пользователях и их данных.
2. Сущность Role - содержит информацию о ролях пользователей.
3. Сущность Missing_animals – хранит информацию о пропавших животных.
4. Сущность Status - хранит статусы о пропавших домашних животных
5. Сущность Category animals – хранит информацию о виде животного.
6. Сущность Breed animals – хранит информацию о породе животного.
7. Сущность Found_animals - хранит информацию о найденных животных. 
![drawSQL-image-export-2024-03-09](https://github.com/nikitasik4ik/HSE_Architecture/assets/81356111/27eb9ce4-eb72-4ac3-bd20-c5af87def43f)

## Применение основных принципов разработки
Клиентский код:
```
import requests

class MissingAnimalsService:
    def __init__(self, base_url):
        self.base_url = base_url
    
    def search(self, animal_name):
        response = requests.get(f"{self.base_url}/missing_animals?animal_name={animal_name}")
        return response.json()

class Found AnimalsService:
    def __init__(self, base_url):
        self.base_url = base_url
    
    def search(self, animal_name):
        response = requests.get(f"{self.base_url}/found_animals?animal_name={animal_name}")
        return response.json()
```
1. Классы MissingAnimalsService и FoundAnimalsService реализованы с помощью конструктора и метода search, что соответствует принципу DRY (Don't Repeat Yourself).
2. Каждый класс имеет свою отдельную ответственность - поиск пропавших и найденных животных соответственно, что соответствует принципу SOLID (Single Responsibility Principle).
3. Используется модуль requests для выполнения HTTP-запросов, что соответствует принципу YAGNI (You Ain't Gonna Need It), так как он не является частью проекта, но может быть использован в будущем.
4. MissingAnimalsService и FoundAnimalsService являются независимыми друг от друга, что соответствует принципу SOLID (Single Responsibility Principle).

Серверный код:

```
from fastapi import FastAPI, JSONResponse
from database import Database

app = FastAPI()
database = Database()

@app.get("/missing_animals")
async def read_missing_animals():
    animal_name = request.query_params.get("animal_name")
    results = database.read_missing_animals(animal_name)
    return JSONResponse(content=results, status_code=200)

@app.get("/found_animals")
async def read_found_animals():
    animal_name = request.query_params.get("animal_name")
    results = database.read_found_animals(animal_name)
    return JSONResponse(content=results, status_code=200)
```
1. Используется фреймворк FastAPI для создания RESTful API, что соответствует принципу YAGNI (You Ain't Gonna Need It), так как он не является частью проекта, но может быть использован в будущем.
2. Используется модуль Database для работы с базой данных, что соответствует принципу DRY (Don't Repeat Yourself).
3. Методы read_missing_animals и read_found_animals выполняют одноимённые операции, что соответствует принципу SOLID (Single Responsibility Principle).
4. Все классы и методы работают вместе, соответствуя принципу KISS (Keep It Simple Stupid).

5 Принципов SOLID:
1. SRP (Принцип единой ответственности) - Оба класса MissingAnimalsService и FoundAnimalsService несут по одной ответственности каждый: поиск пропавших животных и найденных животных соответственно. Это упрощает обслуживание и тестирование этих классов, поскольку у них есть только одна функция для реализации и проверки.
2. OCP (принцип открытости-закрытости) - Предоставленный код не показывает никакой реализации этого принципа напрямую. Однако следование другим принципам SOLID может помочь достичь OCP косвенно. Например, использование интерфейсов или абстрактных классов может упростить добавление новой функциональности без изменения существующего кода.
3. LSP (принцип подстановки Лискова) - Опять же, предоставленный код не показывает никакой реализации этого принципа напрямую. Но, придерживаясь SRP, мы уже делаем наш код более модульным и пригодным для повторного использования, что, в свою очередь, помогает нам следовать LSP. Мы можем создавать подклассы, которые наследуются от MissingAnimalsService или FoundAnimalsService, и быть уверенными, что они будут вести себя корректно при полиморфном использовании.
4. ISP (принцип разделения интерфейсов) - Предоставленный код не использует никаких явных интерфейсов, но мы все равно можем применять ISP неявно, создавая небольшие, сфокусированные методы с четкими обязанностями. В идеале каждый метод должен выполнять только одну задачу, чтобы клиенты могли полагаться только на то, что им нужно.
5. DIP (принцип инверсии зависимостей) - При внедрении зависимостей через конструкторы классы MissingAnimalsService и FoundAnimalsService следуют DIP. Вместо жесткого кодирования своих зависимостей они принимают их в качестве аргументов для своего конструктора. Это позволяет нам легко заменять различные реализации этих зависимостей во время выполнения, если это необходимо.

К серверному коду также применяются некоторые принципы:
1. SRP - Каждый обработчик конечной точки несет единственную ответственность: обработка входящих запросов о пропавших или найденных животных.
2. OCP - Как упоминалось ранее, следование другим принципам SOLID может помочь достичь OCP косвенно.
3. LSP - Поскольку наследуемых классов нет, LSP здесь неуместен.
4. ISP - Каждый обработчик конечной точки фокусируется только на одной задаче, поэтому ISP выполняется неявно.
5. DIP - Обработчики конечных точек зависят от абстракций, а не от конкретных реализаций, что упрощает тестирование и обслуживание.

## Дополнительные принципы разработки
1. BDUF (Big Design Up Front): Этот принцип предполагает, что перед началом разработки необходимо провести масштабное проектирование, чтобы определить все аспекты системы и ее архитектуры. В случае с текущим проектом, это может быть полезным, так как позволит собрать все требования к системе и определить, какие функциональные возможности должны быть реализованы. Однако, применение BDUF также может привести к затягиванию процесса разработки и увеличению времени на разработку.
Данный принцип не применяется для данного проекта.

2. SoC (Separation of Concerns): Принцип разделения ответственности говорит, что каждый компонент системы должен нести единую ответственность и не должен отвечать за множество несвязанных задач. В текущем проекте этот принцип можно применить, разбив систему на более мелкие компоненты, такие как аутентификация пользователей, управление базой данных животных и функциональность поиска. Это упростит обслуживание и обновление системы в будущем.
Данный принцип не применяется для данного проекта.

3. MVP (Minimum Viable Product): MVP - это принцип, который предполагает создание минимальной версии продукта, которая все еще может представлять ценность для пользователей. В случае данного проекта MVP может включать в себя базовую функциональность для пользователей по созданию профилей, добавлению информации о своих потерянных домашних животных и поиску подходящих животных в базе данных. Такой подход позволяет быстро запустить продукт и собрать отзывы пользователей, прежде чем вкладывать дополнительные ресурсы в его разработку.
Данный принцип применяется для данного проекта. 

4. PoC (Proof of Concept): Доказательство концепции - это прототип или минимально жизнеспособный продукт, который демонстрирует осуществимость идеи или технологии. В контексте данногл проекта PoC может быть создан для проверки эффективности использования поиска потерянных домашних животных с их владельцами. Разработав простой прототип, мы можем проверить концепцию, прежде чем инвестировать в полномасштабную разработку.
Данный принцип применяется для данного проекта.
